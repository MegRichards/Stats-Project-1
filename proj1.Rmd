---
title: "Statisitcal Programming - 2020 - Project 1"
output: rmarkdown::html_document
author: Add your name here
---

Due on Monday, November 2nd by 5:00 pm (17:00), UK local time.

Before you start be sure to read through *all* of the rules and instructions in the `README.md`.

<br/>

### Data

```{r}
library(tidyverse)
f1 = readRDS(file="data/f1.rds")
```


<br/>

### Task 1 - Tidy the data

#### Write up

To begin, we convert the f1 data into a tibble which is a data frame chosen for its useful properties when it comes to working in the tidyverse. Creating a tibble results in a list column which we can then manipulate and pull information from. Using the 'View' function in the console allows us to see that there are 14 entries in this data structure, each containing a list of MRData containing the information we are interested in. 

Therefore, the first step is to use the unnest_wider function such that we progress into the MRData level of the data structure. Next, we notice that as we progress through this data structure, we come across more and more redundant data. Thus, we begin to use the hoist function to extract only the information we are interested in. For example, we hoist only the information from the RaceTable within the MRData column and then within this newly created column RaceTable, we hoist only the information contained within Races. In order to discard irrelevant information, we use the select function to remove the columns once they have had the relevant information extracted. This is standard practice and is repeated after every application of hoist in this task. 

At this point, we have obtained a list column with each list containing two entries. As we want the information contained within both entries, we use the unnest_longer function to expand this list. We then hoist again to obtain the columns race_name, round, date and results. Finally, we have obtained some columns which should appear in the final tidy table - this is promising! However, we note that the type of these columns is different from the type specified in the task. Therefore, we can mutate these columns to coerce their entries into the desired types. Now, we can leave the first 3 columns and focus on getting the remaining information from the column 'results'. 

Since the results for each driver are obtained within this list, we want to apply unnest_longer to this column. In the race_name column, we now get every race repeated. This is what we want, since we eventually want to obtain rows where each represents the result of a driver for a particular race. 

Now, hoist the information 'Driver', 'Constructor', 'positionText' and 'points' from the results column. We choose to hoist the 'positionText' entries rather than the entries in 'position'. This is because the value of the position attribute in the Result element is always an integer, giving the finishing order of all drivers. However, the value of the positionText attribute is either an integer (finishing position), “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified). This is important, since we want to replace the position of the driver with NA if they did not finish for any reason. We do this step now, using the mutate function to replace the position value with NA if it is one of the letters above, but leaving it as the finishing position otherwise. Then, we mutate the columns points and position to have integer types. 

Our table now looks close to the desired result. The next step is to hoist the names of each driver from the driver information and the names of the constructors from the constructor information. Since we want the full names of the drivers, we hoist both the first names and surnames. Then, we use the mutate function along with the paste function to create a new column combining the first and surnames of the drivers into a single entry of their full name. We can then use the select function to remove the columns of first and surname. Finally, we use the relocate function to reorder the columns to match the requirements of the task. 

This data is now tidy, since each variable has its own column, each observation has its own row and each value has its own cell. Therefore, we can use the head function to print out the first 10 rows of this data frame to finish the instructions of the task.


#### Code

```{r task1}
f1_tidy = f1 %>%
  tibble::tibble(f1 = .) %>%
  unnest_wider(f1)%>%
  hoist(
    MRData,
    table = c("RaceTable")
  )%>%
  select(-MRData)%>%
  hoist(
    table,
    races = c("Races")
  )%>%
  select(-table)%>%
  unnest_longer(races)%>%
  hoist(
    races,
    race_name = c("raceName"),
    round = c("round"),
    date = c("date"),
    results = c("Results")
  )%>%
  mutate(date = as.Date(date))%>%
  mutate(round = as.integer(round))%>%
  select(-races)%>%
  unnest_longer(results)%>%
  hoist(
    results,
    driver_info = c("Driver"),
    constructor_info = c("Constructor"),
    position = c("positionText"),
    points = c("points")
  )%>%
  mutate(position = na_if(position, "R"))%>%
  mutate(position = na_if(position, "W"))%>%
  mutate(position = na_if(position, "D"))%>%
  mutate(position = na_if(position, "E"))%>%
  mutate(position = na_if(position, "F"))%>%
  mutate(position = na_if(position, "N"))%>%
  mutate(position = as.integer(position))%>%
  mutate(points = as.integer(points))%>%
  select(-results)%>%
  hoist(
    driver_info,
    first_name = c("givenName"),
    surname = c("familyName")
  )%>%
  select(-driver_info)%>%
  hoist(
    constructor_info,
    constructor = c("name")
  )%>%
  select(-constructor_info)%>%
  mutate(driver = paste(first_name, surname, sep=" "))%>%
  select(-first_name, -surname)%>%
  relocate(race_name, round, date, driver)

head(f1_tidy, 10)
```

<br/>


### Task 2 - Drivers' Championship

#### Write up

<!-- Include write up here -->

#### Code

```{r task2}
f1_task2 = f1_tidy%>%
  select(driver, race_name, position, points)%>%
  group_by(driver) %>%
  mutate(overall_points = sum(points))%>%
  select(-points)%>%
  mutate(overall_points = as.integer(overall_points))%>%
  pivot_wider(
    names_from = race_name, 
    values_from = position
  )%>%
  arrange(desc(overall_points))%>%
  relocate(c("overall_points"), .after = last_col())

f1_task2
```
<br/>

### Task 3 - Cumulative Constructors

#### Write up

<!-- Include write up here -->

#### Code


```{r task3}
f1_tidy%>%
  select(constructor, race_name, points)%>%
  pivot_wider(
    names_from = constructor, 
    values_from = points
  )%>%
  mutate_if(
    is.list,
    ~ purrr::map_dbl(., sum)
  )%>%
  mutate_if(
    is.numeric,
    cumsum)%>%
  pivot_longer(
    !race_name, 
    names_to = "constructor", 
    values_to = "points")%>%
  pivot_wider(
    names_from = race_name, 
    values_from = points
  )%>%
  arrange(-rev(.)[1]) #minus sign to show descending order, rev since we want to reverse the order of columns such that [1] refers to last col, not first
  
```


<br/>

### Task 4 - Visualization

#### Write up

<!-- Include write up here -->

#### Code

```{r task4}

f1_tidy%>%
  select(driver, race_name, points)%>%
  pivot_wider(
    names_from = driver, 
    values_from = points
  )%>%
  mutate_if(
    is.list,
    ~ purrr::map_dbl(., sum)
  )%>%
  mutate_if(
    is.numeric,
    cumsum)%>%
  pivot_longer(
    !race_name, 
    names_to = "driver", 
    values_to = "points")

total_drivers = length(f1_task2[[1]])
ordered_drivers = f1_task2[[1]]
five_to_ten = f1_task2[[1]][6:10]
eleven_to_fifteen = f1_task2[[1]][12:15]
remaining_drivers = f1_task2[[1]][15:total_drivers]
print(ordered_drivers)


driver_cum_points = f1_tidy%>%
  select(driver, race_name, points)%>%
  pivot_wider(
    names_from = driver, 
    values_from = points
  )%>%
  mutate_if(
    is.list,
    ~ purrr::map_dbl(., sum)
  )%>%
  mutate_if(
    is.numeric,
    cumsum)%>%
  pivot_longer(
    !race_name, 
    names_to = "driver", 
    values_to = "points")%>%
  pivot_wider(
    names_from = race_name, 
    values_from = points
  )%>%
  arrange(-rev(.)[1])



driver_points = f1_tidy%>%
  select(driver, race_name, points)%>%
  group_by(driver) %>%
  mutate(overall_points = sum(points))%>%
  mutate(overall_points = as.integer(overall_points))


driver_points


ggplot(
  driver_points, 
  aes(
    x = driver, 
    y = points
    )
  )+
  geom_col(aes(fill = race_name), width = 0.7)

```

<br/>

