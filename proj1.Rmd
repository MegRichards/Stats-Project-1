---
title: "Statisitcal Programming - 2020 - Project 1"
output: rmarkdown::html_document
author: Add your name here
---

Due on Monday, November 2nd by 5:00 pm (17:00), UK local time.

Before you start be sure to read through *all* of the rules and instructions in the `README.md`.

<br/>

### Data

```{r}
library(tidyverse)
library(RColorBrewer)
library(gifski)
library(gganimate)
f1 = readRDS(file="data/f1.rds")
```


<br/>

### Task 1 - Tidy the data

#### Write up

To begin, we convert the f1 data into a tibble which is a data frame chosen for its useful properties when it comes to working in the tidyverse. Creating a tibble results in a list column which we can then manipulate and pull information from. Using the 'View' function in the console allows us to see that there are 14 entries in this data structure, each containing a list of MRData containing the information we are interested in. 

Therefore, the first step is to use the unnest_wider function such that we progress into the MRData level of the data structure. Next, we notice that as we progress through this data structure, we come across more and more redundant data. Thus, we begin to use the hoist function to extract only the information we are interested in. For example, we hoist only the information from the RaceTable within the MRData column and then within this newly created column RaceTable, we hoist only the information contained within Races. In order to discard irrelevant information, we use the select function to remove the columns once they have had the relevant information extracted. This is standard practice and is repeated after every application of hoist in this task. 

At this point, we have obtained a list column with each list containing two entries. As we want the information contained within both entries, we use the unnest_longer function to expand this list. We then hoist again to obtain the columns race_name, round, date and results. Finally, we have obtained some columns which should appear in the final tidy table - this is promising! However, we note that the type of these columns is different from the type specified in the task. Therefore, we can mutate these columns to coerce their entries into the desired types. Now, we can leave the first 3 columns and focus on getting the remaining information from the column 'results'. 

Since the results for each driver are obtained within this list, we want to apply unnest_longer to this column. In the race_name column, we now get every race repeated. This is what we want, since we eventually want to obtain rows where each represents the result of a driver for a particular race. 

Now, hoist the information 'Driver', 'Constructor', 'positionText' and 'points' from the results column. We choose to hoist the 'positionText' entries rather than the entries in 'position'. This is because the value of the position attribute in the Result element is always an integer, giving the finishing order of all drivers. However, the value of the positionText attribute is either an integer (finishing position), “R” (retired), “D” (disqualified), “E” (excluded), “W” (withdrawn), “F” (failed to qualify) or “N” (not classified). This is important, since we want to replace the position of the driver with NA if they did not finish for any reason. We do this step now, using the mutate function to replace the position value with NA if it is one of the letters above, but leaving it as the finishing position otherwise. Then, we mutate the columns points and position to have integer types. 

Our table now looks close to the desired result. The next step is to hoist the names of each driver from the driver information and the names of the constructors from the constructor information. Since we want the full names of the drivers, we hoist both the first names and surnames. Then, we use the mutate function along with the paste function to create a new column combining the first and surnames of the drivers into a single entry of their full name. We can then use the select function to remove the columns of first and surname. Finally, we use the relocate function to reorder the columns to match the requirements of the task. 

This data is now tidy, since each variable has its own column, each observation has its own row and each value has its own cell. Therefore, we can use the head function to print out the first 10 rows of this data frame to finish the instructions of the task.


#### Code

```{r task1}
f1_tidy = f1 %>%
  tibble::tibble(f1 = .) %>%
  unnest_wider(f1)%>%
  hoist(
    MRData,
    table = c("RaceTable")
  )%>%
  select(-MRData)%>%
  hoist(
    table,
    races = c("Races")
  )%>%
  select(-table)%>%
  unnest_longer(races)%>%
  hoist(
    races,
    race_name = c("raceName"),
    round = c("round"),
    date = c("date"),
    results = c("Results")
  )%>%
  mutate(date = as.Date(date))%>%
  mutate(round = as.integer(round))%>%
  select(-races)%>%
  unnest_longer(results)%>%
  hoist(
    results,
    driver_info = c("Driver"),
    constructor_info = c("Constructor"),
    position = c("positionText"),
    points = c("points")
  )%>%
  mutate(position = na_if(position, "R"))%>%
  mutate(position = na_if(position, "W"))%>%
  mutate(position = na_if(position, "D"))%>%
  mutate(position = na_if(position, "E"))%>%
  mutate(position = na_if(position, "F"))%>%
  mutate(position = na_if(position, "N"))%>%
  mutate(position = as.integer(position))%>%
  mutate(points = as.integer(points))%>%
  select(-results)%>%
  hoist(
    driver_info,
    first_name = c("givenName"),
    surname = c("familyName")
  )%>%
  select(-driver_info)%>%
  hoist(
    constructor_info,
    constructor = c("name")
  )%>%
  select(-constructor_info)%>%
  mutate(driver = paste(first_name, surname, sep=" "))%>%
  select(-first_name, -surname)%>%
  relocate(race_name, round, date, driver)

head(f1_tidy, 10)
```

<br/>


### Task 2 - Drivers' Championship

#### Write up

We begin by selecting only the rows of the data frame that are relevant to this task. This could be done by selecting relevant rows or deselecting redundant rows - we chose the former since the computational effort for each option was similar and I believe this option is more obvious. 

Next, we create a "grouped" copy of the table such that we can manipulate the results for each driver individually. We then add a column using the mutate function to sum over the points achieved by each individual driver across all races. Once we have this column of overall points, we no longer need to manipulate the points achieved in each individual race and therefore we remove this column from the data frame with the negation of the select function. 

Since we want to achieve a table with a row for each driver containing their positions in each race, we now want to pivot the data frame so that the race names are expanded into individual columns. We achieve this by the pivot_wider function, obtaining the column names from race_name and the values displayed from the corresponding position of the driver in that particular race.

Finally, we want to change the order of the data frame such that it is now sorted in descending order of points total, rather than in the order the drivers finished in the first race only. We achieve this through application of the arrange function on the overall points column along with the function desc since we want the highest number of points at the top of the table. To conclude, we reorder the columns such that the overall points column is moved to the final column of the table. 

Note that we have assigned this data frame a name 'f1_task2' so that we can reference it in later tasks. Therefore, we must include a line outside of the pipe to print the table. This is the final line in the chunk. 



#### Code

```{r task2}
f1_task2 = f1_tidy%>%
  select(driver, race_name, position, points)%>%
  group_by(driver)%>%
  mutate(overall_points = sum(points))%>%
  select(-points) %>%
  pivot_wider(
    names_from = race_name, 
    values_from = position
  )%>%
  arrange(desc(overall_points))%>%
  relocate(c("overall_points"), .after = last_col())

f1_task2
```
<br/>

### Task 3 - Cumulative Constructors

#### Write up

<!-- Include write up here -->

#### Code


```{r task3}
f1_task3 = f1_tidy%>%
  select(constructor, race_name, points)%>%
  pivot_wider(
    names_from = constructor, 
    values_from = points
  )%>%
  mutate_if(
    is.list,
    ~ purrr::map_dbl(., sum)
  )%>%
  mutate_if(
    is.numeric,
    cumsum)%>%
  pivot_longer(
    !race_name, 
    names_to = "constructor", 
    values_to = "points")%>%
  pivot_wider(
    names_from = race_name, 
    values_from = points
  )%>%
  arrange(-rev(.)[1]) #minus sign to show descending order, rev since we want to reverse the order of columns such that [1] refers to last col, not first

f1_task3
```


<br/>

### Task 4 - Visualization

#### Write up

<!-- Include write up here --> Include that I changed color palette because the standard was too much like a rainbow and gradient and adjusted scale of facet to show range better and meaningful title for animation. animation shows drivers reaching same point total &when they do it eg Lewis is first to reach 300 or somegthing like that

#### Code

```{r task4, fig.height=14, fig.width=14}
driver_points = f1_tidy%>%
  select(driver, race_name, points)%>%
  group_by(driver) 


driver_points[driver_points$race_name == "Australian Grand Prix", 2] <- "AUS"
driver_points[driver_points$race_name == "Bahrain Grand Prix", 2] <- "BHR"
driver_points[driver_points$race_name == "Chinese Grand Prix", 2] <- "CHN"
driver_points[driver_points$race_name == "Azerbaijan Grand Prix", 2] <- "AZE"
driver_points[driver_points$race_name == "Spanish Grand Prix", 2] <- "ESP"
driver_points[driver_points$race_name == "Monaco Grand Prix", 2] <- "MON"
driver_points[driver_points$race_name == "Canadian Grand Prix", 2] <- "CAN"
driver_points[driver_points$race_name == "French Grand Prix", 2] <- "FRA"
driver_points[driver_points$race_name == "Austrian Grand Prix", 2] <- "AUT"
driver_points[driver_points$race_name == "British Grand Prix", 2] <- "GBR"
driver_points[driver_points$race_name == "German Grand Prix", 2] <- "GER"
driver_points[driver_points$race_name == "Hungarian Grand Prix", 2] <- "HUN"
driver_points[driver_points$race_name == "Belgian Grand Prix", 2] <- "BEL"
driver_points[driver_points$race_name == "Italian Grand Prix", 2] <- "ITA"
driver_points[driver_points$race_name == "Singapore Grand Prix", 2] <- "SIN"
driver_points[driver_points$race_name == "Russian Grand Prix", 2] <- "RUS"
driver_points[driver_points$race_name == "Japanese Grand Prix", 2] <- "JPN"
driver_points[driver_points$race_name == "Mexican Grand Prix", 2] <- "MEX"
driver_points[driver_points$race_name == "United States Grand Prix", 2] <- "USA"
driver_points[driver_points$race_name == "Brazilian Grand Prix", 2] <- "BRA"
driver_points[driver_points$race_name == "Abu Dhabi Grand Prix", 2] <- "ABU"

colourCount = length(unique(driver_points$race_name))
getPalette = colorRampPalette(brewer.pal(9, "Set1"))

ggplot(
  driver_points, 
  aes(
    y = reorder(driver, points),
    x = points
    )
  )+
  geom_col(aes(fill = race_name), color = "black", width = 0.7)+ theme(legend.position="bottom") + 
  labs(
    title = "Points achieved cumulatively by drivers throughout the season",
    subtitle = paste("Bars stacked such that points achieved in each race are visible"),
    x = "Cumulative Points",
    y = "Driver")+
  scale_fill_discrete(name = "Race name")+
  scale_fill_manual(values = getPalette(colourCount))

driver_cum_points = driver_points%>%
  mutate_if(
    is.numeric,
    cumsum)

countries = unique(driver_cum_points[[2]])
driver_cum_points$race_name <- factor(driver_cum_points$race_name, levels = countries)

ggplot(
  driver_cum_points,
  aes(
    x = race_name, 
    y = points,
    color = driver
    )
  ) +
  geom_point() +
  facet_wrap(~driver, scales = "free", ncol = 2) +
guides(color=FALSE)+ 
  labs(
    title = "Points achieved cumulatively by drivers throughout the season",
    subtitle = paste("Split to show each drivers individual performance in each race"),
    x = "Race name",
    y = "Cumulative Points")


# obtain only the top 5 drivers' cumulative points
# f1_task2[[1]] gives us list of all drivers
driver_cum_points_top5 = driver_cum_points%>%
  filter(driver == f1_task2[[1]][1]| driver ==  f1_task2[[1]][2] |driver == f1_task2[[1]][3] |driver == f1_task2[[1]][4]| driver == f1_task2[[1]][5])


driver_cum_points_top5$race_name <- factor(driver_cum_points_top5$race_name, levels = countries)

ggplot(
  driver_cum_points_top5, 
  aes(
    x = race_name, 
    y = points,
    group = driver,
    color = driver
    )
  )+
  geom_line() +
  geom_point() + 
  gganimate::transition_reveal(points)+
  labs(
    title = "Driver in poll position changes from beginning to end of season",
    subtitle = paste("Animation to show milestone point tallies reached by top 5 drivers"),
    x = "Race name",
    y = "Cumulative Points")+
  scale_y_continuous(breaks = round(seq(min(driver_cum_points_top5$points), max(driver_cum_points_top5$points), by = 20),1))+
  ylim(0,420)




#repeat for constructor

cons_points = f1_tidy%>%
  select(constructor, race_name, points)%>%
  group_by(constructor) 

cons_points[cons_points$race_name == "Australian Grand Prix", 2] <- "AUS"
cons_points[cons_points$race_name == "Bahrain Grand Prix", 2] <- "BHR"
cons_points[cons_points$race_name == "Chinese Grand Prix", 2] <- "CHN"
cons_points[cons_points$race_name == "Azerbaijan Grand Prix", 2] <- "AZE"
cons_points[cons_points$race_name == "Spanish Grand Prix", 2] <- "ESP"
cons_points[cons_points$race_name == "Monaco Grand Prix", 2] <- "MON"
cons_points[cons_points$race_name == "Canadian Grand Prix", 2] <- "CAN"
cons_points[cons_points$race_name == "French Grand Prix", 2] <- "FRA"
cons_points[cons_points$race_name == "Austrian Grand Prix", 2] <- "AUT"
cons_points[cons_points$race_name == "British Grand Prix", 2] <- "GBR"
cons_points[cons_points$race_name == "German Grand Prix", 2] <- "GER"
cons_points[cons_points$race_name == "Hungarian Grand Prix", 2] <- "HUN"
cons_points[cons_points$race_name == "Belgian Grand Prix", 2] <- "BEL"
cons_points[cons_points$race_name == "Italian Grand Prix", 2] <- "ITA"
cons_points[cons_points$race_name == "Singapore Grand Prix", 2] <- "SIN"
cons_points[cons_points$race_name == "Russian Grand Prix", 2] <- "RUS"
cons_points[cons_points$race_name == "Japanese Grand Prix", 2] <- "JPN"
cons_points[cons_points$race_name == "Mexican Grand Prix", 2] <- "MEX"
cons_points[cons_points$race_name == "United States Grand Prix", 2] <- "USA"
cons_points[cons_points$race_name == "Brazilian Grand Prix", 2] <- "BRA"
cons_points[cons_points$race_name == "Abu Dhabi Grand Prix", 2] <- "ABU"

  
ggplot(
  cons_points, 
  aes(
    y = reorder(constructor, points),
    x = points
    )
  )+
  geom_col(aes(fill = race_name), color = "black", width = 0.7)+ theme(legend.position="bottom") + 
  labs(
    title = "Points achieved cumulatively by constructors throughout the season",
    subtitle = paste("Bars stacked such that points achieved in each race are visible"),
    x = "Cumulative Points",
    y = "Constructor")+
  scale_fill_discrete(name = "Race name")+
  scale_fill_manual(values = getPalette(colourCount))

cons_cum_points = cons_points%>%
  mutate_if(
    is.numeric,
    cumsum)

cons_cum_points$race_name <- factor(cons_cum_points$race_name, levels = countries)


#The top three constructors are way in front of the others
#focus on others 
total_cons = length(f1_task3[[1]])
bottom_cons = f1_task3[[1]][4:total_cons]
cons_cum_points_bottom = cons_cum_points%>%
  filter(!(constructor == f1_task3[[1]][1]) & !(constructor == f1_task3[[1]][2]) & !(constructor == f1_task3[[1]][3]))


ggplot(
  cons_cum_points_bottom, 
  aes(
    x = race_name, 
    y = points,
    group = constructor,
    color = constructor
    )
  )+
  geom_line() +
  geom_point() + 
  labs(
    title = "Focus on cumulative points of constructors outside the top 3",
    x = "Race Name",
    y = "Cumulative Points")+
  scale_y_continuous(breaks = round(seq(min(cons_cum_points_bottom$points), max(cons_cum_points_bottom$points), by = 10),1))+
  ylim(0,155)
```

<br/>

